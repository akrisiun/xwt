// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gdk {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Keymap : GLib.Object {

		public Keymap (IntPtr raw) : base(raw) {}

		protected Keymap() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		[GLib.Signal("direction-changed")]
		public event System.EventHandler DirectionChanged {
			add {
				this.AddSignalHandler ("direction-changed", value);
			}
			remove {
				this.RemoveSignalHandler ("direction-changed", value);
			}
		}

		[GLib.Signal("state_changed")]
		public event System.EventHandler StateChanged {
			add {
				this.AddSignalHandler ("state_changed", value);
			}
			remove {
				this.RemoveSignalHandler ("state_changed", value);
			}
		}

		[GLib.Signal("keys-changed")]
		public event System.EventHandler KeysChanged {
			add {
				this.AddSignalHandler ("keys-changed", value);
			}
			remove {
				this.RemoveSignalHandler ("keys-changed", value);
			}
		}

		static GetDirectionNativeDelegate GetDirection_cb_delegate;
		static GetDirectionNativeDelegate GetDirectionVMCallback {
			get {
				if (GetDirection_cb_delegate == null)
					GetDirection_cb_delegate = new GetDirectionNativeDelegate (GetDirection_cb);
				return GetDirection_cb_delegate;
			}
		}

		static void OverrideGetDirection (GLib.GType gtype)
		{
			OverrideGetDirection (gtype, GetDirectionVMCallback);
		}

		static void OverrideGetDirection (GLib.GType gtype, GetDirectionNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetDirection = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate int GetDirectionNativeDelegate (IntPtr inst);

		static int GetDirection_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				Pango.Direction __result;
				__result = __obj.OnGetDirection ();
				return (int) __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideGetDirection")]
		protected virtual Pango.Direction OnGetDirection ()
		{
			return InternalGetDirection ();
		}

		private Pango.Direction InternalGetDirection ()
		{
			GetDirectionNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetDirection;
			if (unmanaged == null) return (Pango.Direction) 0;

			int __result = unmanaged (this.Handle);
			return (Pango.Direction) __result;
		}

		static HaveBidiLayoutsNativeDelegate HaveBidiLayouts_cb_delegate;
		static HaveBidiLayoutsNativeDelegate HaveBidiLayoutsVMCallback {
			get {
				if (HaveBidiLayouts_cb_delegate == null)
					HaveBidiLayouts_cb_delegate = new HaveBidiLayoutsNativeDelegate (HaveBidiLayouts_cb);
				return HaveBidiLayouts_cb_delegate;
			}
		}

		static void OverrideHaveBidiLayouts (GLib.GType gtype)
		{
			OverrideHaveBidiLayouts (gtype, HaveBidiLayoutsVMCallback);
		}

		static void OverrideHaveBidiLayouts (GLib.GType gtype, HaveBidiLayoutsNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.HaveBidiLayouts = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool HaveBidiLayoutsNativeDelegate (IntPtr inst);

		static bool HaveBidiLayouts_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				__result = __obj.OnHaveBidiLayouts ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideHaveBidiLayouts")]
		protected virtual bool OnHaveBidiLayouts ()
		{
			return InternalHaveBidiLayouts ();
		}

		private bool InternalHaveBidiLayouts ()
		{
			HaveBidiLayoutsNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).HaveBidiLayouts;
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle);
			return __result;
		}

		static GetCapsLockStateNativeDelegate GetCapsLockState_cb_delegate;
		static GetCapsLockStateNativeDelegate GetCapsLockStateVMCallback {
			get {
				if (GetCapsLockState_cb_delegate == null)
					GetCapsLockState_cb_delegate = new GetCapsLockStateNativeDelegate (GetCapsLockState_cb);
				return GetCapsLockState_cb_delegate;
			}
		}

		static void OverrideGetCapsLockState (GLib.GType gtype)
		{
			OverrideGetCapsLockState (gtype, GetCapsLockStateVMCallback);
		}

		static void OverrideGetCapsLockState (GLib.GType gtype, GetCapsLockStateNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetCapsLockState = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GetCapsLockStateNativeDelegate (IntPtr inst);

		static bool GetCapsLockState_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				__result = __obj.OnGetCapsLockState ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideGetCapsLockState")]
		protected virtual bool OnGetCapsLockState ()
		{
			return InternalGetCapsLockState ();
		}

		private bool InternalGetCapsLockState ()
		{
			GetCapsLockStateNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetCapsLockState;
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle);
			return __result;
		}

		static GetNumLockStateNativeDelegate GetNumLockState_cb_delegate;
		static GetNumLockStateNativeDelegate GetNumLockStateVMCallback {
			get {
				if (GetNumLockState_cb_delegate == null)
					GetNumLockState_cb_delegate = new GetNumLockStateNativeDelegate (GetNumLockState_cb);
				return GetNumLockState_cb_delegate;
			}
		}

		static void OverrideGetNumLockState (GLib.GType gtype)
		{
			OverrideGetNumLockState (gtype, GetNumLockStateVMCallback);
		}

		static void OverrideGetNumLockState (GLib.GType gtype, GetNumLockStateNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetNumLockState = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GetNumLockStateNativeDelegate (IntPtr inst);

		static bool GetNumLockState_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				__result = __obj.OnGetNumLockState ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideGetNumLockState")]
		protected virtual bool OnGetNumLockState ()
		{
			return InternalGetNumLockState ();
		}

		private bool InternalGetNumLockState ()
		{
			GetNumLockStateNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetNumLockState;
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle);
			return __result;
		}

		static GetEntriesForKeyvalNativeDelegate GetEntriesForKeyval_cb_delegate;
		static GetEntriesForKeyvalNativeDelegate GetEntriesForKeyvalVMCallback {
			get {
				if (GetEntriesForKeyval_cb_delegate == null)
					GetEntriesForKeyval_cb_delegate = new GetEntriesForKeyvalNativeDelegate (GetEntriesForKeyval_cb);
				return GetEntriesForKeyval_cb_delegate;
			}
		}

		static void OverrideGetEntriesForKeyval (GLib.GType gtype)
		{
			OverrideGetEntriesForKeyval (gtype, GetEntriesForKeyvalVMCallback);
		}

		static void OverrideGetEntriesForKeyval (GLib.GType gtype, GetEntriesForKeyvalNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetEntriesForKeyval = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GetEntriesForKeyvalNativeDelegate (IntPtr inst, uint keyval, IntPtr keys, out int n_keys);

		static bool GetEntriesForKeyval_cb (IntPtr inst, uint keyval, IntPtr keys, out int n_keys)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				__result = __obj.OnGetEntriesForKeyval (keyval, Gdk.KeymapKey.New (keys), out n_keys);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideGetEntriesForKeyval")]
		protected virtual bool OnGetEntriesForKeyval (uint keyval, Gdk.KeymapKey keys, out int n_keys)
		{
			return InternalGetEntriesForKeyval (keyval, keys, out n_keys);
		}

		private bool InternalGetEntriesForKeyval (uint keyval, Gdk.KeymapKey keys, out int n_keys)
		{
			GetEntriesForKeyvalNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetEntriesForKeyval;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr native_keys = GLib.Marshaller.StructureToPtrAlloc (keys);
			bool __result = unmanaged (this.Handle, keyval, native_keys, out n_keys);
			keys = Gdk.KeymapKey.New (native_keys);
			Marshal.FreeHGlobal (native_keys);
			return __result;
		}

		static GetEntriesForKeycodeNativeDelegate GetEntriesForKeycode_cb_delegate;
		static GetEntriesForKeycodeNativeDelegate GetEntriesForKeycodeVMCallback {
			get {
				if (GetEntriesForKeycode_cb_delegate == null)
					GetEntriesForKeycode_cb_delegate = new GetEntriesForKeycodeNativeDelegate (GetEntriesForKeycode_cb);
				return GetEntriesForKeycode_cb_delegate;
			}
		}

		static void OverrideGetEntriesForKeycode (GLib.GType gtype)
		{
			OverrideGetEntriesForKeycode (gtype, GetEntriesForKeycodeVMCallback);
		}

		static void OverrideGetEntriesForKeycode (GLib.GType gtype, GetEntriesForKeycodeNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetEntriesForKeycode = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool GetEntriesForKeycodeNativeDelegate (IntPtr inst, uint hardware_keycode, IntPtr keys, out uint keyvals, out int n_entries);

		static bool GetEntriesForKeycode_cb (IntPtr inst, uint hardware_keycode, IntPtr keys, out uint keyvals, out int n_entries)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				__result = __obj.OnGetEntriesForKeycode (hardware_keycode, Gdk.KeymapKey.New (keys), out keyvals, out n_entries);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideGetEntriesForKeycode")]
		protected virtual bool OnGetEntriesForKeycode (uint hardware_keycode, Gdk.KeymapKey keys, out uint keyvals, out int n_entries)
		{
			return InternalGetEntriesForKeycode (hardware_keycode, keys, out keyvals, out n_entries);
		}

		private bool InternalGetEntriesForKeycode (uint hardware_keycode, Gdk.KeymapKey keys, out uint keyvals, out int n_entries)
		{
			GetEntriesForKeycodeNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetEntriesForKeycode;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr native_keys = GLib.Marshaller.StructureToPtrAlloc (keys);
			bool __result = unmanaged (this.Handle, hardware_keycode, native_keys, out keyvals, out n_entries);
			keys = Gdk.KeymapKey.New (native_keys);
			Marshal.FreeHGlobal (native_keys);
			return __result;
		}

		static LookupKeyNativeDelegate LookupKey_cb_delegate;
		static LookupKeyNativeDelegate LookupKeyVMCallback {
			get {
				if (LookupKey_cb_delegate == null)
					LookupKey_cb_delegate = new LookupKeyNativeDelegate (LookupKey_cb);
				return LookupKey_cb_delegate;
			}
		}

		static void OverrideLookupKey (GLib.GType gtype)
		{
			OverrideLookupKey (gtype, LookupKeyVMCallback);
		}

		static void OverrideLookupKey (GLib.GType gtype, LookupKeyNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.LookupKey = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate uint LookupKeyNativeDelegate (IntPtr inst, IntPtr key);

		static uint LookupKey_cb (IntPtr inst, IntPtr key)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				uint __result;
				__result = __obj.OnLookupKey (Gdk.KeymapKey.New (key));
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideLookupKey")]
		protected virtual uint OnLookupKey (Gdk.KeymapKey key)
		{
			return InternalLookupKey (key);
		}

		private uint InternalLookupKey (Gdk.KeymapKey key)
		{
			LookupKeyNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).LookupKey;
			if (unmanaged == null) return 0;

			IntPtr native_key = GLib.Marshaller.StructureToPtrAlloc (key);
			uint __result = unmanaged (this.Handle, native_key);
			key = Gdk.KeymapKey.New (native_key);
			Marshal.FreeHGlobal (native_key);
			return __result;
		}

		static TranslateKeyboardStateNativeDelegate TranslateKeyboardState_cb_delegate;
		static TranslateKeyboardStateNativeDelegate TranslateKeyboardStateVMCallback {
			get {
				if (TranslateKeyboardState_cb_delegate == null)
					TranslateKeyboardState_cb_delegate = new TranslateKeyboardStateNativeDelegate (TranslateKeyboardState_cb);
				return TranslateKeyboardState_cb_delegate;
			}
		}

		static void OverrideTranslateKeyboardState (GLib.GType gtype)
		{
			OverrideTranslateKeyboardState (gtype, TranslateKeyboardStateVMCallback);
		}

		static void OverrideTranslateKeyboardState (GLib.GType gtype, TranslateKeyboardStateNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.TranslateKeyboardState = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool TranslateKeyboardStateNativeDelegate (IntPtr inst, uint hardware_keycode, int state, int group, out uint keyval, out int effective_group, out int level, out int consumed_modifiers);

		static bool TranslateKeyboardState_cb (IntPtr inst, uint hardware_keycode, int state, int group, out uint keyval, out int effective_group, out int level, out int consumed_modifiers)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				Gdk.ModifierType myconsumed_modifiers;
				__result = __obj.OnTranslateKeyboardState (hardware_keycode, (Gdk.ModifierType) state, group, out keyval, out effective_group, out level, out myconsumed_modifiers);
				consumed_modifiers = (int) myconsumed_modifiers;
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideTranslateKeyboardState")]
		protected virtual bool OnTranslateKeyboardState (uint hardware_keycode, Gdk.ModifierType state, int group, out uint keyval, out int effective_group, out int level, out Gdk.ModifierType consumed_modifiers)
		{
			return InternalTranslateKeyboardState (hardware_keycode, state, group, out keyval, out effective_group, out level, out consumed_modifiers);
		}

		private bool InternalTranslateKeyboardState (uint hardware_keycode, Gdk.ModifierType state, int group, out uint keyval, out int effective_group, out int level, out Gdk.ModifierType consumed_modifiers)
		{
			TranslateKeyboardStateNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).TranslateKeyboardState;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			int native_consumed_modifiers;
			bool __result = unmanaged (this.Handle, hardware_keycode, (int) state, group, out keyval, out effective_group, out level, out native_consumed_modifiers);
			consumed_modifiers = (Gdk.ModifierType) native_consumed_modifiers;
			return __result;
		}

		static AddVirtualModifiersNativeDelegate AddVirtualModifiers_cb_delegate;
		static AddVirtualModifiersNativeDelegate AddVirtualModifiersVMCallback {
			get {
				if (AddVirtualModifiers_cb_delegate == null)
					AddVirtualModifiers_cb_delegate = new AddVirtualModifiersNativeDelegate (AddVirtualModifiers_cb);
				return AddVirtualModifiers_cb_delegate;
			}
		}

		static void OverrideAddVirtualModifiers (GLib.GType gtype)
		{
			OverrideAddVirtualModifiers (gtype, AddVirtualModifiersVMCallback);
		}

		static void OverrideAddVirtualModifiers (GLib.GType gtype, AddVirtualModifiersNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.AddVirtualModifiers = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AddVirtualModifiersNativeDelegate (IntPtr inst, out int state);

		static void AddVirtualModifiers_cb (IntPtr inst, out int state)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				Gdk.ModifierType mystate;
				__obj.OnAddVirtualModifiers (out mystate);
				state = (int) mystate;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideAddVirtualModifiers")]
		protected virtual void OnAddVirtualModifiers (out Gdk.ModifierType state)
		{
			InternalAddVirtualModifiers (out state);
		}

		private void InternalAddVirtualModifiers (out Gdk.ModifierType state)
		{
			AddVirtualModifiersNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).AddVirtualModifiers;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			int native_state;
			unmanaged (this.Handle, out native_state);
			state = (Gdk.ModifierType) native_state;
		}

		static MapVirtualModifiersNativeDelegate MapVirtualModifiers_cb_delegate;
		static MapVirtualModifiersNativeDelegate MapVirtualModifiersVMCallback {
			get {
				if (MapVirtualModifiers_cb_delegate == null)
					MapVirtualModifiers_cb_delegate = new MapVirtualModifiersNativeDelegate (MapVirtualModifiers_cb);
				return MapVirtualModifiers_cb_delegate;
			}
		}

		static void OverrideMapVirtualModifiers (GLib.GType gtype)
		{
			OverrideMapVirtualModifiers (gtype, MapVirtualModifiersVMCallback);
		}

		static void OverrideMapVirtualModifiers (GLib.GType gtype, MapVirtualModifiersNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.MapVirtualModifiers = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool MapVirtualModifiersNativeDelegate (IntPtr inst, out int state);

		static bool MapVirtualModifiers_cb (IntPtr inst, out int state)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				bool __result;
				Gdk.ModifierType mystate;
				__result = __obj.OnMapVirtualModifiers (out mystate);
				state = (int) mystate;
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideMapVirtualModifiers")]
		protected virtual bool OnMapVirtualModifiers (out Gdk.ModifierType state)
		{
			return InternalMapVirtualModifiers (out state);
		}

		private bool InternalMapVirtualModifiers (out Gdk.ModifierType state)
		{
			MapVirtualModifiersNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).MapVirtualModifiers;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			int native_state;
			bool __result = unmanaged (this.Handle, out native_state);
			state = (Gdk.ModifierType) native_state;
			return __result;
		}

		static DirectionChangedNativeDelegate DirectionChanged_cb_delegate;
		static DirectionChangedNativeDelegate DirectionChangedVMCallback {
			get {
				if (DirectionChanged_cb_delegate == null)
					DirectionChanged_cb_delegate = new DirectionChangedNativeDelegate (DirectionChanged_cb);
				return DirectionChanged_cb_delegate;
			}
		}

		static void OverrideDirectionChanged (GLib.GType gtype)
		{
			OverrideDirectionChanged (gtype, DirectionChangedVMCallback);
		}

		static void OverrideDirectionChanged (GLib.GType gtype, DirectionChangedNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.DirectionChanged = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void DirectionChangedNativeDelegate (IntPtr inst);

		static void DirectionChanged_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				__obj.OnDirectionChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideDirectionChanged")]
		protected virtual void OnDirectionChanged ()
		{
			InternalDirectionChanged ();
		}

		private void InternalDirectionChanged ()
		{
			DirectionChangedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).DirectionChanged;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static KeysChangedNativeDelegate KeysChanged_cb_delegate;
		static KeysChangedNativeDelegate KeysChangedVMCallback {
			get {
				if (KeysChanged_cb_delegate == null)
					KeysChanged_cb_delegate = new KeysChangedNativeDelegate (KeysChanged_cb);
				return KeysChanged_cb_delegate;
			}
		}

		static void OverrideKeysChanged (GLib.GType gtype)
		{
			OverrideKeysChanged (gtype, KeysChangedVMCallback);
		}

		static void OverrideKeysChanged (GLib.GType gtype, KeysChangedNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.KeysChanged = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void KeysChangedNativeDelegate (IntPtr inst);

		static void KeysChanged_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				__obj.OnKeysChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideKeysChanged")]
		protected virtual void OnKeysChanged ()
		{
			InternalKeysChanged ();
		}

		private void InternalKeysChanged ()
		{
			KeysChangedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).KeysChanged;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		static StateChangedNativeDelegate StateChanged_cb_delegate;
		static StateChangedNativeDelegate StateChangedVMCallback {
			get {
				if (StateChanged_cb_delegate == null)
					StateChanged_cb_delegate = new StateChangedNativeDelegate (StateChanged_cb);
				return StateChanged_cb_delegate;
			}
		}

		static void OverrideStateChanged (GLib.GType gtype)
		{
			OverrideStateChanged (gtype, StateChangedVMCallback);
		}

		static void OverrideStateChanged (GLib.GType gtype, StateChangedNativeDelegate callback)
		{
			GdkKeymapClass class_iface = GetClassStruct (gtype, false);
			class_iface.StateChanged = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void StateChangedNativeDelegate (IntPtr inst);

		static void StateChanged_cb (IntPtr inst)
		{
			try {
				Keymap __obj = GLib.Object.GetObject (inst, false) as Keymap;
				__obj.OnStateChanged ();
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(Gdk.Keymap), ConnectionMethod="OverrideStateChanged")]
		protected virtual void OnStateChanged ()
		{
			InternalStateChanged ();
		}

		private void InternalStateChanged ()
		{
			StateChangedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).StateChanged;
			if (unmanaged == null) return;

			unmanaged (this.Handle);
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GdkKeymapClass {
			public GetDirectionNativeDelegate GetDirection;
			public HaveBidiLayoutsNativeDelegate HaveBidiLayouts;
			public GetCapsLockStateNativeDelegate GetCapsLockState;
			public GetNumLockStateNativeDelegate GetNumLockState;
			public GetEntriesForKeyvalNativeDelegate GetEntriesForKeyval;
			public GetEntriesForKeycodeNativeDelegate GetEntriesForKeycode;
			public LookupKeyNativeDelegate LookupKey;
			public TranslateKeyboardStateNativeDelegate TranslateKeyboardState;
			public AddVirtualModifiersNativeDelegate AddVirtualModifiers;
			public MapVirtualModifiersNativeDelegate MapVirtualModifiers;
			public DirectionChangedNativeDelegate DirectionChanged;
			public KeysChangedNativeDelegate KeysChanged;
			public StateChangedNativeDelegate StateChanged;
		}

		static uint class_offset = ((GLib.GType) typeof (GLib.Object)).GetClassSize ();
		static Dictionary<GLib.GType, GdkKeymapClass> class_structs;

		static GdkKeymapClass GetClassStruct (GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Dictionary<GLib.GType, GdkKeymapClass> ();

			if (use_cache && class_structs.ContainsKey (gtype))
				return class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GdkKeymapClass class_struct = (GdkKeymapClass) Marshal.PtrToStructure (class_ptr, typeof (GdkKeymapClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (GLib.GType gtype, GdkKeymapClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gdk_keymap_add_virtual_modifiers(IntPtr raw, out int state);

		public Gdk.ModifierType AddVirtualModifiers() {
			Gdk.ModifierType state;
			int native_state;
			gdk_keymap_add_virtual_modifiers(Handle, out native_state);
			state = (Gdk.ModifierType) native_state;
			return state;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gdk_keymap_get_caps_lock_state(IntPtr raw);

		public bool CapsLockState { 
			get {
				bool raw_ret = gdk_keymap_get_caps_lock_state(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gdk_keymap_get_default();

		public static Gdk.Keymap Default { 
			get {
				IntPtr raw_ret = gdk_keymap_get_default();
				Gdk.Keymap ret = GLib.Object.GetObject(raw_ret) as Gdk.Keymap;
				return ret;
			}
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gdk_keymap_get_direction(IntPtr raw);

		public Pango.Direction Direction { 
			get {
				int raw_ret = gdk_keymap_get_direction(Handle);
				Pango.Direction ret = (Pango.Direction) raw_ret;
				return ret;
			}
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gdk_keymap_get_for_display(IntPtr display);

		public static Gdk.Keymap GetForDisplay(Gdk.Display display) {
			IntPtr raw_ret = gdk_keymap_get_for_display(display == null ? IntPtr.Zero : display.Handle);
			Gdk.Keymap ret = GLib.Object.GetObject(raw_ret) as Gdk.Keymap;
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gdk_keymap_get_num_lock_state(IntPtr raw);

		public bool NumLockState { 
			get {
				bool raw_ret = gdk_keymap_get_num_lock_state(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gdk_keymap_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = gdk_keymap_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gdk_keymap_have_bidi_layouts(IntPtr raw);

		public bool HaveBidiLayouts() {
			bool raw_ret = gdk_keymap_have_bidi_layouts(Handle);
			bool ret = raw_ret;
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern uint gdk_keymap_lookup_key(IntPtr raw, IntPtr key);

		public uint LookupKey(Gdk.KeymapKey key) {
			IntPtr native_key = GLib.Marshaller.StructureToPtrAlloc (key);
			uint raw_ret = gdk_keymap_lookup_key(Handle, native_key);
			uint ret = raw_ret;
			key = Gdk.KeymapKey.New (native_key);
			Marshal.FreeHGlobal (native_key);
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gdk_keymap_map_virtual_modifiers(IntPtr raw, out int state);

		public bool MapVirtualModifiers(out Gdk.ModifierType state) {
			int native_state;
			bool raw_ret = gdk_keymap_map_virtual_modifiers(Handle, out native_state);
			bool ret = raw_ret;
			state = (Gdk.ModifierType) native_state;
			return ret;
		}

		[DllImport("libgdk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gdk_keymap_translate_keyboard_state(IntPtr raw, uint hardware_keycode, int state, int group, out uint keyval, out int effective_group, out int level, out int consumed_modifiers);

		public bool TranslateKeyboardState(uint hardware_keycode, Gdk.ModifierType state, int group, out uint keyval, out int effective_group, out int level, out Gdk.ModifierType consumed_modifiers) {
			int native_consumed_modifiers;
			bool raw_ret = gdk_keymap_translate_keyboard_state(Handle, hardware_keycode, (int) state, group, out keyval, out effective_group, out level, out native_consumed_modifiers);
			bool ret = raw_ret;
			consumed_modifiers = (Gdk.ModifierType) native_consumed_modifiers;
			return ret;
		}

#endregion
	}
}
