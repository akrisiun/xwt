// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace Gtk {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class IconInfo : GLib.Opaque {

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_icon_info_copy(IntPtr raw);

		public Gtk.IconInfo Copy() {
			IntPtr raw_ret = gtk_icon_info_copy(Handle);
			Gtk.IconInfo ret = raw_ret == IntPtr.Zero ? null : (Gtk.IconInfo) GLib.Opaque.GetOpaque (raw_ret, typeof (Gtk.IconInfo), true);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_icon_info_get_attach_points(IntPtr raw, IntPtr points, out int n_points);

		public bool GetAttachPoints(Gdk.Point points, out int n_points) {
			IntPtr native_points = GLib.Marshaller.StructureToPtrAlloc (points);
			bool raw_ret = gtk_icon_info_get_attach_points(Handle, native_points, out n_points);
			bool ret = raw_ret;
			points = Gdk.Point.New (native_points);
			Marshal.FreeHGlobal (native_points);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern int gtk_icon_info_get_base_size(IntPtr raw);

		public int BaseSize { 
			get {
				int raw_ret = gtk_icon_info_get_base_size(Handle);
				int ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_icon_info_get_builtin_pixbuf(IntPtr raw);

		public Gdk.Pixbuf BuiltinPixbuf { 
			get {
				IntPtr raw_ret = gtk_icon_info_get_builtin_pixbuf(Handle);
				Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixbuf;
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_icon_info_get_display_name(IntPtr raw);

		public string DisplayName { 
			get {
				IntPtr raw_ret = gtk_icon_info_get_display_name(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool gtk_icon_info_get_embedded_rect(IntPtr raw, IntPtr rectangle);

		public bool GetEmbeddedRect(Gdk.Rectangle rectangle) {
			IntPtr native_rectangle = GLib.Marshaller.StructureToPtrAlloc (rectangle);
			bool raw_ret = gtk_icon_info_get_embedded_rect(Handle, native_rectangle);
			bool ret = raw_ret;
			rectangle = (Gdk.Rectangle) Marshal.PtrToStructure (native_rectangle, typeof (Gdk.Rectangle));
			Marshal.FreeHGlobal (native_rectangle);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_icon_info_get_filename(IntPtr raw);

		[DllImport("libgtk-3-0.dll")]
		static extern IntPtr gtk_icon_info_get_filename_utf8(IntPtr raw);

		public string Filename { 
			get {
				IntPtr raw_ret;
				if (Environment.OSVersion.Platform == PlatformID.Win32NT ||
				    Environment.OSVersion.Platform == PlatformID.Win32S ||
				    Environment.OSVersion.Platform == PlatformID.Win32Windows ||
				    Environment.OSVersion.Platform == PlatformID.WinCE)
					raw_ret = gtk_icon_info_get_filename_utf8(Handle);
				else
					raw_ret = gtk_icon_info_get_filename(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_icon_info_get_type();

		public static GLib.GType GType { 
			get {
				IntPtr raw_ret = gtk_icon_info_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe IntPtr gtk_icon_info_load_icon(IntPtr raw, out IntPtr error);

		public unsafe Gdk.Pixbuf LoadIcon() {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = gtk_icon_info_load_icon(Handle, out error);
			Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixbuf;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe IntPtr gtk_icon_info_load_symbolic(IntPtr raw, IntPtr fg, IntPtr success_color, IntPtr warning_color, IntPtr error_color, out bool was_symbolic, out IntPtr error);

		public unsafe Gdk.Pixbuf LoadSymbolic(Gdk.RGBA fg, Gdk.RGBA success_color, Gdk.RGBA warning_color, Gdk.RGBA error_color, out bool was_symbolic) {
			IntPtr native_fg = GLib.Marshaller.StructureToPtrAlloc (fg);
			IntPtr native_success_color = GLib.Marshaller.StructureToPtrAlloc (success_color);
			IntPtr native_warning_color = GLib.Marshaller.StructureToPtrAlloc (warning_color);
			IntPtr native_error_color = GLib.Marshaller.StructureToPtrAlloc (error_color);
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = gtk_icon_info_load_symbolic(Handle, native_fg, native_success_color, native_warning_color, native_error_color, out was_symbolic, out error);
			Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixbuf;
			fg = Gdk.RGBA.New (native_fg);
			Marshal.FreeHGlobal (native_fg);
			success_color = Gdk.RGBA.New (native_success_color);
			Marshal.FreeHGlobal (native_success_color);
			warning_color = Gdk.RGBA.New (native_warning_color);
			Marshal.FreeHGlobal (native_warning_color);
			error_color = Gdk.RGBA.New (native_error_color);
			Marshal.FreeHGlobal (native_error_color);
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe IntPtr gtk_icon_info_load_symbolic_for_context(IntPtr raw, IntPtr context, out bool was_symbolic, out IntPtr error);

		public unsafe Gdk.Pixbuf LoadSymbolicForContext(Gtk.StyleContext context, out bool was_symbolic) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = gtk_icon_info_load_symbolic_for_context(Handle, context == null ? IntPtr.Zero : context.Handle, out was_symbolic, out error);
			Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixbuf;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern unsafe IntPtr gtk_icon_info_load_symbolic_for_style(IntPtr raw, IntPtr style, int state, out bool was_symbolic, out IntPtr error);

		[Obsolete]
		public unsafe Gdk.Pixbuf LoadSymbolicForStyle(Gtk.Style style, Gtk.StateType state, out bool was_symbolic) {
			IntPtr error = IntPtr.Zero;
			IntPtr raw_ret = gtk_icon_info_load_symbolic_for_style(Handle, style == null ? IntPtr.Zero : style.Handle, (int) state, out was_symbolic, out error);
			Gdk.Pixbuf ret = GLib.Object.GetObject(raw_ret) as Gdk.Pixbuf;
			if (error != IntPtr.Zero) throw new GLib.GException (error);
			return ret;
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_icon_info_set_raw_coordinates(IntPtr raw, bool raw_coordinates);

		public bool RawCoordinates { 
			set {
				gtk_icon_info_set_raw_coordinates(Handle, value);
			}
		}

		public IconInfo(IntPtr raw) : base(raw) {}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr gtk_icon_info_new_for_pixbuf(IntPtr icon_theme, IntPtr pixbuf);

		public IconInfo (Gtk.IconTheme icon_theme, Gdk.Pixbuf pixbuf) 
		{
			Raw = gtk_icon_info_new_for_pixbuf(icon_theme == null ? IntPtr.Zero : icon_theme.Handle, pixbuf == null ? IntPtr.Zero : pixbuf.Handle);
		}

		[DllImport("libgtk-3-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern void gtk_icon_info_free(IntPtr raw);

		protected override void Free (IntPtr raw)
		{
			gtk_icon_info_free (raw);
		}

		[Obsolete("Gtk.IconInfo is now freed automatically")]
		public void Free () {}

		class FinalizerInfo {
			IntPtr handle;

			public FinalizerInfo (IntPtr handle)
			{
				this.handle = handle;
			}

			public bool Handler ()
			{
				gtk_icon_info_free (handle);
				return false;
			}
		}

		~IconInfo ()
		{
			if (!Owned)
				return;
			FinalizerInfo info = new FinalizerInfo (Handle);
			GLib.Timeout.Add (50, new GLib.TimeoutHandler (info.Handler));
		}

#endregion
	}
}
