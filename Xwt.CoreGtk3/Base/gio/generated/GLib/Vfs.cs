// This file was generated by the Gtk# code generator.
// Any changes made will be lost if regenerated.

namespace GLib {

	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.Runtime.InteropServices;

#region Autogenerated code
	public partial class Vfs : GLib.Object {

		public Vfs (IntPtr raw) : base(raw) {}

		protected Vfs() : base(IntPtr.Zero)
		{
			CreateNativeObject (new string [0], new GLib.Value [0]);
		}

		static IsActiveNativeDelegate IsActive_cb_delegate;
		static IsActiveNativeDelegate IsActiveVMCallback {
			get {
				if (IsActive_cb_delegate == null)
					IsActive_cb_delegate = new IsActiveNativeDelegate (IsActive_cb);
				return IsActive_cb_delegate;
			}
		}

		static void OverrideIsActive (GLib.GType gtype)
		{
			OverrideIsActive (gtype, IsActiveVMCallback);
		}

		static void OverrideIsActive (GLib.GType gtype, IsActiveNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.IsActive = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool IsActiveNativeDelegate (IntPtr inst);

		static bool IsActive_cb (IntPtr inst)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				bool __result;
				__result = __obj.OnIsActive ();
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideIsActive")]
		protected virtual bool OnIsActive ()
		{
			return InternalIsActive ();
		}

		private bool InternalIsActive ()
		{
			IsActiveNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).IsActive;
			if (unmanaged == null) return false;

			bool __result = unmanaged (this.Handle);
			return __result;
		}

		static GetFileForPathNativeDelegate GetFileForPath_cb_delegate;
		static GetFileForPathNativeDelegate GetFileForPathVMCallback {
			get {
				if (GetFileForPath_cb_delegate == null)
					GetFileForPath_cb_delegate = new GetFileForPathNativeDelegate (GetFileForPath_cb);
				return GetFileForPath_cb_delegate;
			}
		}

		static void OverrideGetFileForPath (GLib.GType gtype)
		{
			OverrideGetFileForPath (gtype, GetFileForPathVMCallback);
		}

		static void OverrideGetFileForPath (GLib.GType gtype, GetFileForPathNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetFileForPath = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetFileForPathNativeDelegate (IntPtr inst, IntPtr path);

		static IntPtr GetFileForPath_cb (IntPtr inst, IntPtr path)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				GLib.IFile __result;
				__result = __obj.OnGetFileForPath (GLib.Marshaller.Utf8PtrToString (path));
				return __result == null ? IntPtr.Zero : ((__result is GLib.Object) ? (__result as GLib.Object).Handle : (__result as GLib.FileAdapter).Handle);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideGetFileForPath")]
		protected virtual GLib.IFile OnGetFileForPath (string path)
		{
			return InternalGetFileForPath (path);
		}

		private GLib.IFile InternalGetFileForPath (string path)
		{
			GetFileForPathNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetFileForPath;
			if (unmanaged == null) return null;

			IntPtr native_path = GLib.Marshaller.StringToPtrGStrdup (path);
			IntPtr __result = unmanaged (this.Handle, native_path);
			GLib.Marshaller.Free (native_path);
			return GLib.FileAdapter.GetObject (__result, false);
		}

		static GetFileForUriNativeDelegate GetFileForUri_cb_delegate;
		static GetFileForUriNativeDelegate GetFileForUriVMCallback {
			get {
				if (GetFileForUri_cb_delegate == null)
					GetFileForUri_cb_delegate = new GetFileForUriNativeDelegate (GetFileForUri_cb);
				return GetFileForUri_cb_delegate;
			}
		}

		static void OverrideGetFileForUri (GLib.GType gtype)
		{
			OverrideGetFileForUri (gtype, GetFileForUriVMCallback);
		}

		static void OverrideGetFileForUri (GLib.GType gtype, GetFileForUriNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.GetFileForUri = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr GetFileForUriNativeDelegate (IntPtr inst, IntPtr uri);

		static IntPtr GetFileForUri_cb (IntPtr inst, IntPtr uri)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				GLib.IFile __result;
				__result = __obj.OnGetFileForUri (GLib.Marshaller.Utf8PtrToString (uri));
				return __result == null ? IntPtr.Zero : ((__result is GLib.Object) ? (__result as GLib.Object).Handle : (__result as GLib.FileAdapter).Handle);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideGetFileForUri")]
		protected virtual GLib.IFile OnGetFileForUri (string uri)
		{
			return InternalGetFileForUri (uri);
		}

		private GLib.IFile InternalGetFileForUri (string uri)
		{
			GetFileForUriNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).GetFileForUri;
			if (unmanaged == null) return null;

			IntPtr native_uri = GLib.Marshaller.StringToPtrGStrdup (uri);
			IntPtr __result = unmanaged (this.Handle, native_uri);
			GLib.Marshaller.Free (native_uri);
			return GLib.FileAdapter.GetObject (__result, false);
		}

		static ParseNameNativeDelegate ParseName_cb_delegate;
		static ParseNameNativeDelegate ParseNameVMCallback {
			get {
				if (ParseName_cb_delegate == null)
					ParseName_cb_delegate = new ParseNameNativeDelegate (ParseName_cb);
				return ParseName_cb_delegate;
			}
		}

		static void OverrideParseName (GLib.GType gtype)
		{
			OverrideParseName (gtype, ParseNameVMCallback);
		}

		static void OverrideParseName (GLib.GType gtype, ParseNameNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.ParseName = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate IntPtr ParseNameNativeDelegate (IntPtr inst, IntPtr parse_name);

		static IntPtr ParseName_cb (IntPtr inst, IntPtr parse_name)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				GLib.IFile __result;
				__result = __obj.OnParseName (GLib.Marshaller.Utf8PtrToString (parse_name));
				return __result == null ? IntPtr.Zero : ((__result is GLib.Object) ? (__result as GLib.Object).Handle : (__result as GLib.FileAdapter).Handle);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideParseName")]
		protected virtual GLib.IFile OnParseName (string parse_name)
		{
			return InternalParseName (parse_name);
		}

		private GLib.IFile InternalParseName (string parse_name)
		{
			ParseNameNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).ParseName;
			if (unmanaged == null) return null;

			IntPtr native_parse_name = GLib.Marshaller.StringToPtrGStrdup (parse_name);
			IntPtr __result = unmanaged (this.Handle, native_parse_name);
			GLib.Marshaller.Free (native_parse_name);
			return GLib.FileAdapter.GetObject (__result, false);
		}

		static LocalFileAddInfoNativeDelegate LocalFileAddInfo_cb_delegate;
		static LocalFileAddInfoNativeDelegate LocalFileAddInfoVMCallback {
			get {
				if (LocalFileAddInfo_cb_delegate == null)
					LocalFileAddInfo_cb_delegate = new LocalFileAddInfoNativeDelegate (LocalFileAddInfo_cb);
				return LocalFileAddInfo_cb_delegate;
			}
		}

		static void OverrideLocalFileAddInfo (GLib.GType gtype)
		{
			OverrideLocalFileAddInfo (gtype, LocalFileAddInfoVMCallback);
		}

		static void OverrideLocalFileAddInfo (GLib.GType gtype, LocalFileAddInfoNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.LocalFileAddInfo = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void LocalFileAddInfoNativeDelegate (IntPtr inst, IntPtr filename, ulong device, IntPtr attribute_matcher, IntPtr info, IntPtr cancellable, IntPtr extra_data, out GLib.DestroyNotify free_extra_data);

		static void LocalFileAddInfo_cb (IntPtr inst, IntPtr filename, ulong device, IntPtr attribute_matcher, IntPtr info, IntPtr cancellable, IntPtr extra_data, out GLib.DestroyNotify free_extra_data)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				__obj.OnLocalFileAddInfo (GLib.Marshaller.Utf8PtrToString (filename), device, attribute_matcher == IntPtr.Zero ? null : (GLib.FileAttributeMatcher) GLib.Opaque.GetOpaque (attribute_matcher, typeof (GLib.FileAttributeMatcher), false), GLib.Object.GetObject(info) as GLib.FileInfo, GLib.Object.GetObject(cancellable) as GLib.Cancellable, extra_data, out free_extra_data);
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideLocalFileAddInfo")]
		protected virtual void OnLocalFileAddInfo (string filename, ulong device, GLib.FileAttributeMatcher attribute_matcher, GLib.FileInfo info, GLib.Cancellable cancellable, IntPtr extra_data, out GLib.DestroyNotify free_extra_data)
		{
			InternalLocalFileAddInfo (filename, device, attribute_matcher, info, cancellable, extra_data, out free_extra_data);
		}

		private void InternalLocalFileAddInfo (string filename, ulong device, GLib.FileAttributeMatcher attribute_matcher, GLib.FileInfo info, GLib.Cancellable cancellable, IntPtr extra_data, out GLib.DestroyNotify free_extra_data)
		{
			LocalFileAddInfoNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).LocalFileAddInfo;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
			unmanaged (this.Handle, native_filename, device, attribute_matcher == null ? IntPtr.Zero : attribute_matcher.Handle, info == null ? IntPtr.Zero : info.Handle, cancellable == null ? IntPtr.Zero : cancellable.Handle, extra_data, out free_extra_data);
			GLib.Marshaller.Free (native_filename);
		}

		static AddWritableNamespacesNativeDelegate AddWritableNamespaces_cb_delegate;
		static AddWritableNamespacesNativeDelegate AddWritableNamespacesVMCallback {
			get {
				if (AddWritableNamespaces_cb_delegate == null)
					AddWritableNamespaces_cb_delegate = new AddWritableNamespacesNativeDelegate (AddWritableNamespaces_cb);
				return AddWritableNamespaces_cb_delegate;
			}
		}

		static void OverrideAddWritableNamespaces (GLib.GType gtype)
		{
			OverrideAddWritableNamespaces (gtype, AddWritableNamespacesVMCallback);
		}

		static void OverrideAddWritableNamespaces (GLib.GType gtype, AddWritableNamespacesNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.AddWritableNamespaces = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void AddWritableNamespacesNativeDelegate (IntPtr inst, IntPtr list);

		static void AddWritableNamespaces_cb (IntPtr inst, IntPtr list)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				__obj.OnAddWritableNamespaces (list == IntPtr.Zero ? null : (GLib.FileAttributeInfoList) GLib.Opaque.GetOpaque (list, typeof (GLib.FileAttributeInfoList), false));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideAddWritableNamespaces")]
		protected virtual void OnAddWritableNamespaces (GLib.FileAttributeInfoList list)
		{
			InternalAddWritableNamespaces (list);
		}

		private void InternalAddWritableNamespaces (GLib.FileAttributeInfoList list)
		{
			AddWritableNamespacesNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).AddWritableNamespaces;
			if (unmanaged == null) return;

			unmanaged (this.Handle, list == null ? IntPtr.Zero : list.Handle);
		}

		static LocalFileSetAttributesNativeDelegate LocalFileSetAttributes_cb_delegate;
		static LocalFileSetAttributesNativeDelegate LocalFileSetAttributesVMCallback {
			get {
				if (LocalFileSetAttributes_cb_delegate == null)
					LocalFileSetAttributes_cb_delegate = new LocalFileSetAttributesNativeDelegate (LocalFileSetAttributes_cb);
				return LocalFileSetAttributes_cb_delegate;
			}
		}

		static void OverrideLocalFileSetAttributes (GLib.GType gtype)
		{
			OverrideLocalFileSetAttributes (gtype, LocalFileSetAttributesVMCallback);
		}

		static void OverrideLocalFileSetAttributes (GLib.GType gtype, LocalFileSetAttributesNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.LocalFileSetAttributes = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate bool LocalFileSetAttributesNativeDelegate (IntPtr inst, IntPtr filename, IntPtr info, int flags, IntPtr cancellable, out IntPtr error);

		static bool LocalFileSetAttributes_cb (IntPtr inst, IntPtr filename, IntPtr info, int flags, IntPtr cancellable, out IntPtr error)
		{
			error = IntPtr.Zero;

			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				bool __result;
				__result = __obj.OnLocalFileSetAttributes (GLib.Marshaller.Utf8PtrToString (filename), GLib.Object.GetObject(info) as GLib.FileInfo, (GLib.FileQueryInfoFlags) flags, GLib.Object.GetObject(cancellable) as GLib.Cancellable);
				return __result;
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, true);
				// NOTREACHED: above call does not return.
				throw e;
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideLocalFileSetAttributes")]
		protected virtual bool OnLocalFileSetAttributes (string filename, GLib.FileInfo info, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable)
		{
			return InternalLocalFileSetAttributes (filename, info, flags, cancellable);
		}

		private bool InternalLocalFileSetAttributes (string filename, GLib.FileInfo info, GLib.FileQueryInfoFlags flags, GLib.Cancellable cancellable)
		{
			LocalFileSetAttributesNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).LocalFileSetAttributes;
			if (unmanaged == null) throw new InvalidOperationException ("No base method to invoke");

			IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
			IntPtr error = IntPtr.Zero;
			bool __result = unmanaged (this.Handle, native_filename, info == null ? IntPtr.Zero : info.Handle, (int) flags, cancellable == null ? IntPtr.Zero : cancellable.Handle, out error);
			GLib.Marshaller.Free (native_filename);
			return __result;
		}

		static LocalFileRemovedNativeDelegate LocalFileRemoved_cb_delegate;
		static LocalFileRemovedNativeDelegate LocalFileRemovedVMCallback {
			get {
				if (LocalFileRemoved_cb_delegate == null)
					LocalFileRemoved_cb_delegate = new LocalFileRemovedNativeDelegate (LocalFileRemoved_cb);
				return LocalFileRemoved_cb_delegate;
			}
		}

		static void OverrideLocalFileRemoved (GLib.GType gtype)
		{
			OverrideLocalFileRemoved (gtype, LocalFileRemovedVMCallback);
		}

		static void OverrideLocalFileRemoved (GLib.GType gtype, LocalFileRemovedNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.LocalFileRemoved = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void LocalFileRemovedNativeDelegate (IntPtr inst, IntPtr filename);

		static void LocalFileRemoved_cb (IntPtr inst, IntPtr filename)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				__obj.OnLocalFileRemoved (GLib.Marshaller.Utf8PtrToString (filename));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideLocalFileRemoved")]
		protected virtual void OnLocalFileRemoved (string filename)
		{
			InternalLocalFileRemoved (filename);
		}

		private void InternalLocalFileRemoved (string filename)
		{
			LocalFileRemovedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).LocalFileRemoved;
			if (unmanaged == null) return;

			IntPtr native_filename = GLib.Marshaller.StringToPtrGStrdup (filename);
			unmanaged (this.Handle, native_filename);
			GLib.Marshaller.Free (native_filename);
		}

		static LocalFileMovedNativeDelegate LocalFileMoved_cb_delegate;
		static LocalFileMovedNativeDelegate LocalFileMovedVMCallback {
			get {
				if (LocalFileMoved_cb_delegate == null)
					LocalFileMoved_cb_delegate = new LocalFileMovedNativeDelegate (LocalFileMoved_cb);
				return LocalFileMoved_cb_delegate;
			}
		}

		static void OverrideLocalFileMoved (GLib.GType gtype)
		{
			OverrideLocalFileMoved (gtype, LocalFileMovedVMCallback);
		}

		static void OverrideLocalFileMoved (GLib.GType gtype, LocalFileMovedNativeDelegate callback)
		{
			GVfsClass class_iface = GetClassStruct (gtype, false);
			class_iface.LocalFileMoved = callback;
			OverrideClassStruct (gtype, class_iface);
		}

		[UnmanagedFunctionPointer (CallingConvention.Cdecl)]
		delegate void LocalFileMovedNativeDelegate (IntPtr inst, IntPtr source, IntPtr dest);

		static void LocalFileMoved_cb (IntPtr inst, IntPtr source, IntPtr dest)
		{
			try {
				Vfs __obj = GLib.Object.GetObject (inst, false) as Vfs;
				__obj.OnLocalFileMoved (GLib.Marshaller.Utf8PtrToString (source), GLib.Marshaller.Utf8PtrToString (dest));
			} catch (Exception e) {
				GLib.ExceptionManager.RaiseUnhandledException (e, false);
			}
		}

		[GLib.DefaultSignalHandler(Type=typeof(GLib.Vfs), ConnectionMethod="OverrideLocalFileMoved")]
		protected virtual void OnLocalFileMoved (string source, string dest)
		{
			InternalLocalFileMoved (source, dest);
		}

		private void InternalLocalFileMoved (string source, string dest)
		{
			LocalFileMovedNativeDelegate unmanaged = GetClassStruct (this.LookupGType ().GetThresholdType (), true).LocalFileMoved;
			if (unmanaged == null) return;

			IntPtr native_source = GLib.Marshaller.StringToPtrGStrdup (source);
			IntPtr native_dest = GLib.Marshaller.StringToPtrGStrdup (dest);
			unmanaged (this.Handle, native_source, native_dest);
			GLib.Marshaller.Free (native_source);
			GLib.Marshaller.Free (native_dest);
		}

		[StructLayout (LayoutKind.Sequential)]
		struct GVfsClass {
			public IsActiveNativeDelegate IsActive;
			public GetFileForPathNativeDelegate GetFileForPath;
			public GetFileForUriNativeDelegate GetFileForUri;
			IntPtr GetSupportedUriSchemes;
			public ParseNameNativeDelegate ParseName;
			public LocalFileAddInfoNativeDelegate LocalFileAddInfo;
			public AddWritableNamespacesNativeDelegate AddWritableNamespaces;
			public LocalFileSetAttributesNativeDelegate LocalFileSetAttributes;
			public LocalFileRemovedNativeDelegate LocalFileRemoved;
			public LocalFileMovedNativeDelegate LocalFileMoved;
			IntPtr GReserved1;
			IntPtr GReserved2;
			IntPtr GReserved3;
			IntPtr GReserved4;
			IntPtr GReserved5;
			IntPtr GReserved6;
			IntPtr GReserved7;
		}

		static uint class_offset = ((GLib.GType) typeof (GLib.Object)).GetClassSize ();
		static Dictionary<GLib.GType, GVfsClass> class_structs;

		static GVfsClass GetClassStruct (GLib.GType gtype, bool use_cache)
		{
			if (class_structs == null)
				class_structs = new Dictionary<GLib.GType, GVfsClass> ();

			if (use_cache && class_structs.ContainsKey (gtype))
				return class_structs [gtype];
			else {
				IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
				GVfsClass class_struct = (GVfsClass) Marshal.PtrToStructure (class_ptr, typeof (GVfsClass));
				if (use_cache)
					class_structs.Add (gtype, class_struct);
				return class_struct;
			}
		}

		static void OverrideClassStruct (GLib.GType gtype, GVfsClass class_struct)
		{
			IntPtr class_ptr = new IntPtr (gtype.GetClassPtr ().ToInt64 () + class_offset);
			Marshal.StructureToPtr (class_struct, class_ptr, false);
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_get_default();

		public static GLib.Vfs Default { 
			get {
				IntPtr raw_ret = g_vfs_get_default();
				GLib.Vfs ret = GLib.Object.GetObject(raw_ret) as GLib.Vfs;
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_get_file_for_path(IntPtr raw, IntPtr path);

		public GLib.IFile GetFileForPath(string path) {
			IntPtr native_path = GLib.Marshaller.StringToPtrGStrdup (path);
			IntPtr raw_ret = g_vfs_get_file_for_path(Handle, native_path);
			GLib.IFile ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_path);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_get_file_for_uri(IntPtr raw, IntPtr uri);

		public GLib.IFile GetFileForUri(string uri) {
			IntPtr native_uri = GLib.Marshaller.StringToPtrGStrdup (uri);
			IntPtr raw_ret = g_vfs_get_file_for_uri(Handle, native_uri);
			GLib.IFile ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_uri);
			return ret;
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_get_local();

		public static GLib.Vfs Local { 
			get {
				IntPtr raw_ret = g_vfs_get_local();
				GLib.Vfs ret = GLib.Object.GetObject(raw_ret) as GLib.Vfs;
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_get_supported_uri_schemes(IntPtr raw);

		public string SupportedUriSchemes { 
			get {
				IntPtr raw_ret = g_vfs_get_supported_uri_schemes(Handle);
				string ret = GLib.Marshaller.Utf8PtrToString (raw_ret);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_get_type();

		public static new GLib.GType GType { 
			get {
				IntPtr raw_ret = g_vfs_get_type();
				GLib.GType ret = new GLib.GType(raw_ret);
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern bool g_vfs_is_active(IntPtr raw);

		public bool IsActive { 
			get {
				bool raw_ret = g_vfs_is_active(Handle);
				bool ret = raw_ret;
				return ret;
			}
		}

		[DllImport("libgio-2.0-0.dll", CallingConvention = CallingConvention.Cdecl)]
		static extern IntPtr g_vfs_parse_name(IntPtr raw, IntPtr parse_name);

		public GLib.IFile ParseName(string parse_name) {
			IntPtr native_parse_name = GLib.Marshaller.StringToPtrGStrdup (parse_name);
			IntPtr raw_ret = g_vfs_parse_name(Handle, native_parse_name);
			GLib.IFile ret = GLib.FileAdapter.GetObject (raw_ret, false);
			GLib.Marshaller.Free (native_parse_name);
			return ret;
		}

#endregion
	}
}
